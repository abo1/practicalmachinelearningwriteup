<!DOCTYPE html>
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<meta http-equiv="x-ua-compatible" content="IE=9">

<title>Practical Machine Learning Project</title>

<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 12px;
   margin: 8px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 { 
   font-size:2.2em; 
}

h2 { 
   font-size:1.8em; 
}

h3 { 
   font-size:1.4em; 
}

h4 { 
   font-size:1.0em; 
}

h5 { 
   font-size:0.9em; 
}

h6 { 
   font-size:0.8em; 
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre {	
   margin-top: 0;
   max-width: 95%;
   border: 1px solid #ccc;
   white-space: pre-wrap;
}

pre code {
   display: block; padding: 0.5em;
}

code.r, code.cpp {
   background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * { 
      background: transparent !important; 
      color: black !important; 
      filter:none !important; 
      -ms-filter: none !important; 
   }

   body { 
      font-size:12pt; 
      max-width:100%; 
   }
       
   a, a:visited { 
      text-decoration: underline; 
   }

   hr { 
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote { 
      padding-right: 1em; 
      page-break-inside: avoid; 
   }

   tr, img { 
      page-break-inside: avoid; 
   }

   img { 
      max-width: 100% !important; 
   }

   @page :left { 
      margin: 15mm 20mm 15mm 10mm; 
   }
     
   @page :right { 
      margin: 15mm 10mm 15mm 20mm; 
   }

   p, h2, h3 { 
      orphans: 3; widows: 3; 
   }

   h2, h3 { 
      page-break-after: avoid; 
   }
}

</style>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: rgb(88, 72, 246)
   }

   pre .number {
     color: rgb(0, 0, 205);
   }

   pre .comment {
     color: rgb(76, 136, 107);
   }

   pre .keyword {
     color: rgb(0, 0, 255);
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: rgb(3, 106, 7);
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>




</head>

<body>
<h1>Practical Machne Learning Project</h1>

<p>In this report, we use machine learning algorithms to predict the category of movement that human text subjects intentionally exhibited when performing a simple physical exercise, based on sensor data.</p>

<h1>Obtaining the data</h1>

<p>We begin by downloading both the labeled and unlabeled data sets from the Cloudfront host. The labeled set is marked with the category of movement that the test subject was performing. The unlabeled set has no such labels; the whole point of our machine learning exercise is to determine what we think these labels should be in the unlabeled data.</p>

<pre><code class="r"><span class="identifier">download.file</span><span class="paren">(</span><span class="string">"https://d396qusza40orc.cloudfront.net/predmachlearn/pml-training.csv"</span>, 
    <span class="string">"pml-training.csv"</span>, <span class="identifier">method</span> <span class="operator">=</span> <span class="string">"curl"</span><span class="paren">)</span>
<span class="identifier">pmlLabeled</span> <span class="operator">&lt;-</span> <span class="identifier">read.csv</span><span class="paren">(</span><span class="string">"pml-training.csv"</span><span class="paren">)</span>

<span class="identifier">download.file</span><span class="paren">(</span><span class="string">"https://d396qusza40orc.cloudfront.net/predmachlearn/pml-testing.csv"</span>, 
    <span class="string">"pml-testing.csv"</span>, <span class="identifier">method</span> <span class="operator">=</span> <span class="string">"curl"</span><span class="paren">)</span>
<span class="identifier">pmlUnlabeled</span> <span class="operator">&lt;-</span> <span class="identifier">read.csv</span><span class="paren">(</span><span class="string">"pml-testing.csv"</span><span class="paren">)</span>
</code></pre>

<h1>Dividing the training set</h1>

<p>We separate our labeled data into a training set and a validation set. This will allow us to determine how well our learning algorithm is likely to perform on the unlabeled data.</p>

<pre><code class="r"><span class="keyword">library</span><span class="paren">(</span><span class="identifier">caret</span><span class="paren">)</span>
</code></pre>

<pre><code>## Loading required package: lattice
## Loading required package: ggplot2
</code></pre>

<pre><code class="r"><span class="identifier">set.seed</span><span class="paren">(</span><span class="number">8765309</span><span class="paren">)</span>
<span class="identifier">pmlInTraining</span> <span class="operator">&lt;-</span> <span class="identifier">createDataPartition</span><span class="paren">(</span><span class="identifier">pmlLabeled</span><span class="operator">$</span><span class="identifier">classe</span>, <span class="identifier">p</span> <span class="operator">=</span> <span class="number">0.8</span>, <span class="identifier">list</span> <span class="operator">=</span> <span class="literal">FALSE</span><span class="paren">)</span>
<span class="identifier">pmlTraining</span> <span class="operator">&lt;-</span> <span class="identifier">pmlLabeled</span><span class="paren">[</span><span class="identifier">pmlInTraining</span>, <span class="paren">]</span>
<span class="identifier">pmlTesting</span> <span class="operator">&lt;-</span> <span class="identifier">pmlLabeled</span><span class="paren">[</span><span class="operator">-</span><span class="identifier">pmlInTraining</span>, <span class="paren">]</span>
</code></pre>

<h1>Distributing the dimensionality of data</h1>

<p>Before we can meaningfully apply machine learning techniques to the data, we should first clean the data to improve both computational time and final model accuracy.</p>

<h2>Discarding unnecessary columns</h2>

<p>Most of the columns in the training data set are either empty or filled with invalid data (NA, empty space, etc.). We therefore clean the data by first observing which columns have most of their contents filled in, and only keeping those. If a column mostly consists of NA's and/or empty space, we toss it out.</p>

<pre><code class="r"><span class="identifier">pmlColumnFillCounts</span> <span class="operator">&lt;-</span> <span class="identifier">sapply</span><span class="paren">(</span><span class="identifier">pmlTraining</span>, <span class="keyword">function</span><span class="paren">(</span><span class="identifier">col</span><span class="paren">)</span> <span class="paren">{</span>
    <span class="identifier">sum</span><span class="paren">(</span><span class="operator">!</span><span class="paren">(</span><span class="identifier">is.na</span><span class="paren">(</span><span class="identifier">col</span><span class="paren">)</span> <span class="operator">|</span> <span class="identifier">col</span> <span class="operator">==</span> <span class="string">""</span><span class="paren">)</span><span class="paren">)</span>
<span class="paren">}</span><span class="paren">)</span>
<span class="identifier">pmlFullColumns</span> <span class="operator">&lt;-</span> <span class="identifier">names</span><span class="paren">(</span><span class="identifier">pmlColumnFillCounts</span><span class="paren">[</span><span class="identifier">pmlColumnFillCounts</span> <span class="operator">==</span> <span class="identifier">length</span><span class="paren">(</span><span class="identifier">pmlTraining</span><span class="operator">$</span><span class="identifier">classe</span><span class="paren">)</span><span class="paren">]</span><span class="paren">)</span>
</code></pre>

<h2>Discarding columns that lead to overfitting</h2>

<p>While we're here, let's also omit all the timestamp and window columns, because those will encourage our machine learning model to overfit. Likewise, we'll omit the “user_name” column for the same reason. Our model should learn to classify the user's actions based on what motions the user is performing, not by what time the user is peforming them or who the user happens to be.</p>

<p>We'll also omit the label column itself, “classe”. This is the dependent variable in our data set, so we'll handle it separately.</p>

<pre><code class="r"><span class="identifier">pmlFullColumns</span> <span class="operator">&lt;-</span> <span class="identifier">pmlFullColumns</span><span class="paren">[</span><span class="operator">!</span><span class="identifier">pmlFullColumns</span> <span class="operator">%in%</span> <span class="identifier">c</span><span class="paren">(</span><span class="string">"X"</span>, <span class="string">"user_name"</span>, <span class="string">"raw_timestamp_part_1"</span>, 
    <span class="string">"raw_timestamp_part_2"</span>, <span class="string">"cvtd_timestamp"</span>, <span class="string">"new_window"</span>, <span class="string">"num_window"</span>, <span class="string">"classe"</span><span class="paren">)</span><span class="paren">]</span>
</code></pre>

<p>These steps dramatically reduce the number of dimensions we have to work with, thus making our data much more manageable.</p>

<pre><code class="r"><span class="identifier">pmlTrainingTrimmed</span> <span class="operator">&lt;-</span> <span class="identifier">pmlTraining</span><span class="paren">[</span>, <span class="identifier">pmlFullColumns</span><span class="paren">]</span>

<span class="identifier">data.frame</span><span class="paren">(</span><span class="identifier">column_count_before_discarding_mostly_empty_columns</span> <span class="operator">=</span> <span class="identifier">ncol</span><span class="paren">(</span><span class="identifier">pmlTraining</span><span class="paren">)</span>, 
    <span class="identifier">column_count_after_discarding_mostly_empty_columns</span> <span class="operator">=</span> <span class="identifier">ncol</span><span class="paren">(</span><span class="identifier">pmlTrainingTrimmed</span><span class="paren">)</span><span class="paren">)</span>
</code></pre>

<pre><code>##   column_count_before_discarding_mostly_empty_columns
## 1                                                 160
##   column_count_after_discarding_mostly_empty_columns
## 1                                                 52
</code></pre>

<h1>Training a model</h1>

<p>We'll use a Generalized Boosted Regression Model with Stochastic Gradient Boosting (method label “gbm”) to try to predict the values in this data set. We'll tell it to run for 300 iterations with a step size of .1; these values are drawn from GBM's default settings, but with a higher iteration count so as to allow the model to converge more closely to a high-quality solution.</p>

<pre><code class="r"><span class="identifier">pmlTrainControl</span> <span class="operator">&lt;-</span> <span class="identifier">trainControl</span><span class="paren">(</span><span class="identifier">method</span> <span class="operator">=</span> <span class="string">"none"</span><span class="paren">)</span>
<span class="identifier">pmlTuneGrid</span> <span class="operator">&lt;-</span> <span class="identifier">data.frame</span><span class="paren">(</span><span class="identifier">interaction.depth</span> <span class="operator">=</span> <span class="number">4</span>, <span class="identifier">n.trees</span> <span class="operator">=</span> <span class="number">300</span>, <span class="identifier">shrinkage</span> <span class="operator">=</span> <span class="number">0.1</span><span class="paren">)</span>

<span class="identifier">pmlModel</span> <span class="operator">&lt;-</span> <span class="identifier">train</span><span class="paren">(</span><span class="identifier">pmlTrainingTrimmed</span>, <span class="identifier">pmlTraining</span><span class="operator">$</span><span class="identifier">classe</span>, <span class="identifier">method</span> <span class="operator">=</span> <span class="string">"gbm"</span>, <span class="identifier">trControl</span> <span class="operator">=</span> <span class="identifier">pmlTrainControl</span>, 
    <span class="identifier">tuneGrid</span> <span class="operator">=</span> <span class="identifier">pmlTuneGrid</span><span class="paren">)</span>
</code></pre>

<pre><code>## Loading required package: gbm
## Loading required package: survival
## Loading required package: splines
## 
## Attaching package: 'survival'
## 
## The following object is masked from 'package:caret':
## 
##     cluster
## 
## Loading required package: parallel
## Loaded gbm 2.1
## Loading required package: plyr
</code></pre>

<pre><code>## Iter   TrainDeviance   ValidDeviance   StepSize   Improve
##      1        1.6094             nan     0.1000    0.2751
##      2        1.4360             nan     0.1000    0.1982
##      3        1.3118             nan     0.1000    0.1421
##      4        1.2221             nan     0.1000    0.1246
##      5        1.1457             nan     0.1000    0.0959
##      6        1.0855             nan     0.1000    0.0897
##      7        1.0300             nan     0.1000    0.0709
##      8        0.9854             nan     0.1000    0.0800
##      9        0.9364             nan     0.1000    0.0593
##     10        0.8978             nan     0.1000    0.0524
##     20        0.6513             nan     0.1000    0.0212
##     40        0.4239             nan     0.1000    0.0122
##     60        0.3131             nan     0.1000    0.0059
##     80        0.2435             nan     0.1000    0.0039
##    100        0.1933             nan     0.1000    0.0025
##    120        0.1588             nan     0.1000    0.0022
##    140        0.1323             nan     0.1000    0.0011
##    160        0.1125             nan     0.1000    0.0010
##    180        0.0961             nan     0.1000    0.0008
##    200        0.0829             nan     0.1000    0.0008
##    220        0.0714             nan     0.1000    0.0002
##    240        0.0626             nan     0.1000    0.0005
##    260        0.0550             nan     0.1000    0.0003
##    280        0.0483             nan     0.1000    0.0002
##    300        0.0427             nan     0.1000    0.0002
</code></pre>

<pre><code class="r">
<span class="identifier">pmlModel</span>
</code></pre>

<pre><code>## Stochastic Gradient Boosting 
## 
## 15699 samples
##    52 predictors
##     5 classes: 'A', 'B', 'C', 'D', 'E' 
## 
## No pre-processing
## Resampling: None
</code></pre>

<h2>Validating model by using out-of-sample data</h2>

<p>Let's see how well the model that we just created performs against data it's never seen before. At the beginning of this report, we set aside a small partition of the labeled data to use as a validation set. We'll now use our model to predict what it thinks the labels on this validation data should be, and compare the model's predictions to our actual labels.</p>

<pre><code class="r"><span class="identifier">pmlTestingLabelsPred</span> <span class="operator">&lt;-</span> <span class="identifier">predict</span><span class="paren">(</span><span class="identifier">pmlModel</span>, <span class="identifier">newdata</span> <span class="operator">=</span> <span class="identifier">pmlTesting</span><span class="paren">[</span>, <span class="identifier">pmlFullColumns</span><span class="paren">]</span><span class="paren">)</span>
<span class="identifier">pmlConfusionMatrix</span> <span class="operator">&lt;-</span> <span class="identifier">confusionMatrix</span><span class="paren">(</span><span class="identifier">pmlTestingLabelsPred</span>, <span class="identifier">pmlTesting</span><span class="operator">$</span><span class="identifier">classe</span><span class="paren">)</span>
<span class="identifier">pmlConfusionMatrix</span>
</code></pre>

<pre><code>## Confusion Matrix and Statistics
## 
##           Reference
## Prediction    A    B    C    D    E
##          A 1112    9    0    0    0
##          B    3  738    5    0    4
##          C    1   12  678    8    1
##          D    0    0    1  634    6
##          E    0    0    0    1  710
## 
## Overall Statistics
##                                        
##                Accuracy : 0.987        
##                  95% CI : (0.983, 0.99)
##     No Information Rate : 0.284        
##     P-Value [Acc &gt; NIR] : &lt;2e-16       
##                                        
##                   Kappa : 0.984        
##  Mcnemar's Test P-Value : NA           
## 
## Statistics by Class:
## 
##                      Class: A Class: B Class: C Class: D Class: E
## Sensitivity             0.996    0.972    0.991    0.986    0.985
## Specificity             0.997    0.996    0.993    0.998    1.000
## Pos Pred Value          0.992    0.984    0.969    0.989    0.999
## Neg Pred Value          0.999    0.993    0.998    0.997    0.997
## Prevalence              0.284    0.193    0.174    0.164    0.184
## Detection Rate          0.283    0.188    0.173    0.162    0.181
## Detection Prevalence    0.286    0.191    0.178    0.163    0.181
## Balanced Accuracy       0.997    0.984    0.992    0.992    0.992
</code></pre>

<h3>Out-of-sample error</h3>

<p>The out-of-sample error, as determined by validating the model against a labeled testing partition originally withheld from the training data, is the following value:</p>

<pre><code class="r"><span class="paren">(</span><span class="number">1</span> <span class="operator">-</span> <span class="identifier">pmlConfusionMatrix</span><span class="operator">$</span><span class="identifier">overall</span><span class="paren">[</span><span class="string">"Accuracy"</span><span class="paren">]</span><span class="paren">)</span><span class="paren">[</span><span class="paren">[</span><span class="number">1</span><span class="paren">]</span><span class="paren">]</span>
</code></pre>

<pre><code>## [1] 0.013
</code></pre>

<h1>Answers for the unlabeled data</h1>

<p>We can now use our model to predict the appropriate labels for our unlabeled data set.</p>

<pre><code class="r"><span class="identifier">pmlAnswers</span> <span class="operator">&lt;-</span> <span class="identifier">predict</span><span class="paren">(</span><span class="identifier">pmlModel</span>, <span class="identifier">newdata</span> <span class="operator">=</span> <span class="identifier">pmlUnlabeled</span><span class="paren">[</span>, <span class="identifier">pmlFullColumns</span><span class="paren">]</span><span class="paren">)</span>
<span class="identifier">pmlAnswers</span>
</code></pre>

<pre><code>##  [1] B A B A A E D B A A B C B A E E A B B B
## Levels: A B C D E
</code></pre>

<p>It is these values that we will submit for evaluation to the online grading system.</p>





</body></html>
